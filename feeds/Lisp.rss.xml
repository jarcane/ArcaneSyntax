<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Arcane Syntax: Posts tagged 'Lisp'</title>
  <description>Arcane Syntax: Posts tagged 'Lisp'</description>
  <link>http://jarcane.github.com/tags/Lisp.html</link>
  <lastBuildDate>Mon, 15 Sep 2014 23:22:25 FLE Standard Time</lastBuildDate>
  <pubDate>Mon, 15 Sep 2014 23:22:25 FLE Standard Time</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Choosing a Lisp</title>
   <link>http://jarcane.github.com/blog/2014/09/15/choosing-a-lisp.html</link>
   <guid>urn:http-jarcane-github-com:-blog-2014-09-15-choosing-a-lisp-html</guid>
   <pubDate>Mon, 15 Sep 2014 23:22:25 FLE Standard Time</pubDate>
   <description>&lt;html&gt;
&lt;p&gt;I began my adventure back into the world of programming with Python. My last book had started to peter out in sales, and I began seriously re-evaluating my career potential, and it was at this point that a friend introduced me to &lt;a href="http://codecademy.com"&gt;Codecademy&lt;/a&gt;. I was immediately taken with the interactive approach to programming instruction, and in particular gravitated to Python, because it was a language I&amp;rsquo;d tinkered with before and whose power, especially in strings and lists, I&amp;rsquo;d always been impressed with.&lt;/p&gt;

&lt;p&gt;I devoured the Python course greedily and soon moved on to my first &amp;ldquo;big&amp;rdquo; project, &lt;a href="https://github.com/jarcane/handhRL"&gt;handhRL&lt;/a&gt; a roguelike based on one of my tabletop rulesets. However, as I grappled with the tedium of building random object generators with massive elseif-based constructor patterns, and the poor performance and gaming potential, I also was acutely aware I&amp;rsquo;d need to branch out into other languages.&lt;/p&gt;

&lt;p&gt;And then another friend recommended I try Lisp. I consider it a fateful day. I&amp;rsquo;m not honestly certain whether to curse him for it or thank him. I tried a number of entryways into the world, and indeed, choosing which Lisp to focus on has consumed much of the last two months of my time. I fall more in love with Lisp the more I learn of it, but choosing a flavor of it has tormented me more than perhaps it should.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what I have learned.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;There are a dizzying array of Lisps out there, but by and large the main options boil down to the following:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Common Lisp&lt;/li&gt;
 &lt;li&gt;Scheme&lt;/li&gt;
 &lt;li&gt;Clojure&lt;/li&gt;
 &lt;li&gt;Racket&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;There&amp;rsquo;s more of course, Paul Graham has Arc which powers Hacker News, there&amp;rsquo;s the venerable Emacs Lisp that powers the very editor I write these posts on, but those four are probably the most prominent and feasible for at least some practical amount of actual work.&lt;/p&gt;

&lt;p&gt;I started with Common Lisp. Or at least, attempting it. I suspect many people do, those that don&amp;rsquo;t instead get exposed to Scheme in college. I suspect now I understand why so many come away with a bad impression. Common Lisp is far easier to learn now than it was 10 years ago, but it&amp;rsquo;s still a dialect built on compromises and mired in ancient and cthonian syntax. I found myself stymied by having to learn 12 different ways of doing any given thing, and by chapter-long exercises done entirely in a REPL that then crashed or fell victim to an error somewhere back on page 2.&lt;/p&gt;

&lt;p&gt;So, from there I cast around and found Racket. And lo, the heavens did open, and mine eyes did see the light. While I did catch glimpses of the power of Lisp with my initial toolings, it was in the purity and clarity of Racket, in its wonderful documentation, in the easy power of the Lisp&amp;ndash;1, that I found the full breadth of what I&amp;rsquo;d seen as I stumbled through the CL wilderness. I played and tinkered and hacked. I wrote an &lt;a href="https://github.com/jarcane/MicroMini"&gt;8-bit VM&lt;/a&gt; in just 206 lines of code. 206!&lt;/p&gt;

&lt;p&gt;But I stumbled as well. I ran into problems implementing terminal i/o with my virtual machine, so it would only run in Linux. I found myself frustrated by the lack of mature development for pretty common &amp;ldquo;getting work done&amp;rdquo; tasks, at least for the kind of work I wanted to do. As well, I found myself stymied by the books and documentation; put off by the beginner material, but utterly baffled by the advanced features.&lt;/p&gt;

&lt;p&gt;I made another run at Common Lisp, getting pretty far in Peter Seibel&amp;rsquo;s excellent &lt;a href="http://www.gigamonkeys.com/book/"&gt;Practical Common Lisp&lt;/a&gt;. Ultimately though, more exposure to the many-splendored weirdness of CL ultimately lead me to think perhaps it just wasn&amp;rsquo;t the flavor for me.&lt;/p&gt;

&lt;p&gt;Another friend had mentioned Clojure. I was put off by Clojure up until now, because it reeked of startup culture and I frankly have a long-standing grudge against Java. But Java is practically the reigning Lord and Master of the mobile-heavy Finnish scene, and it seemed to be driving a lot of new adoption locally and even a few actual jobs.&lt;/p&gt;

&lt;p&gt;So, I discussed it with my wife and we mutually agreed I should give it a shot. I meditated upon the &lt;a href="http://clojurescriptkoans.com/"&gt;ClojureScript Koans&lt;/a&gt;, and was initially quite intrigued by its #() and its funcional purity, if a bit baffled by the sheer number of different data types, and put off by the ugly syntax. I code-golfed a FizzBuzz in a tweet done in CS. I then thought I should meditate upon the full &lt;a href="https://github.com/functional-koans/clojure-koans"&gt;Clojure Koans&lt;/a&gt; in order to learn those things which CS had by necessity neglected.&lt;/p&gt;

&lt;p&gt;By the end, the only &amp;ldquo;enlightenment&amp;rdquo; I found there was the cold burning focus of pure fury. I hated its clunky implementation, it&amp;rsquo;s utter violation of the purity I so loved in a Lisp. I hated how utterly inconsistent everything was. I hated how any error could spell utter doom to your entire system, as typo&amp;rsquo;d recursions led to full CPUs and runaway threads. I hate hate hated the threading macro with the fire of a thousand incandescent supernovas.&lt;/p&gt;

&lt;p&gt;However, it also gave me a sense of perspective, and so I meditated on the &lt;a href="https://github.com/google/lisp-koans"&gt;Common Lisp Koans&lt;/a&gt;. There I faced a an anticlimax. The final meditation was on SBCL threads, and SBCL threads were like grasping a stream of water. I had recieved all the enlightenment that Common Lisp seemed ready to offer.&lt;/p&gt;

&lt;p&gt;And in the end, all I wanted was my Racket back. The prodigal son wanted to come home.&lt;/p&gt;

&lt;p&gt;I am sure that in the cold light of reason I could find work in Clojure or Common Lisp. I do indeed envy their library support, and have come to respect a number of those features that they offer, and may even seek to reimplement some of them in my own Racket set up.&lt;/p&gt;

&lt;p&gt;It is true as well that Racket is not well represented in the world of working programmers. But it is well represented in the world of computer science, a world I increasingly suspect I might like to enter if I should prove worthy. While there is something of a gap between the &amp;ldquo;beginner&amp;rdquo; and &amp;ldquo;advanced&amp;rdquo; levels of the Racket world, the flipside to this is that it is stuffed with incredibly brilliant people who are almost to a one the most polite and helpful people I&amp;rsquo;ve met since returning to programming.&lt;/p&gt;

&lt;p&gt;So, with at least a year of language courses before I can even think about a job or university, why not hang around and contribute and learn in a place where I feel most at home? It was Python being this for me that made me a programmer again, and I think it could be Racket doing so that makes me a &lt;em&gt;good&lt;/em&gt; one.&lt;/p&gt;&lt;/html&gt;</description></item></channel></rss>